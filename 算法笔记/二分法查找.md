# 二分查找

### 【前提条件】

- 有序
- 无重复元素



### 【边界条件&区间定义】

- ##### 左闭右闭，[left, right]

  **`while`使用`<=`**，即

  - `while(left <= right)`
  - `if(nuts[middle]>target)`，则`right = mid - 1`,
  - `if(nuts[middle]>target)`，则`left = mid + 1`。

  例子：

  在数组[1,2,3,4,7,9,10] 中查找元素

  ```java
   public int binarySearch(int[] nums, int target) {
          if (nums.length == 0) {
              return -1;
          }
          if (target < nums[0] && target > nums[nums.length - 1]) {
              return -1;
          }
          int left = 0, right = nums.length - 1;   //定义索引区间
          while (left <= right) {     
              int mid = (left + right) >> 1;       //定义中间索引
              if (nums[mid] == target) {
                  return mid;
              }
              if (nums[mid] > target) {
                  right = mid - 1; //target 在左区间，所以[left, middle - 1]
              } else {
                  left = mid + 1;  //target 在右区间，所以[middle + 1, right]
              }
          }
          return -1;
      }
  ```

  

- ##### 左闭右开，[left, right)

  **`while`使用`<`**，即

  - `while(left < right)`
  - `if(nuts[middle]>target)`，则`right = mid`,
  - `if(nuts[middle]>target)`，则`left = mid + 1`。

  例子

  在数组[1,2,3,4,7,9,10) 中查找元素

  ```java
   public static int binarySearch2(int[] nums, int target){
          if (nums.length == 0) {
              return -1;
          }
          if (target < nums[0] && target > nums[nums.length - 1]) {
              return -1;
          }
  
          int left = 0, right = nums.length - 1;   //定义索引区间
          while (left < right) {    ///-------------不同点-------------
  
              int mid = (left + right) >> 1;   //定义中间索引
              if (nums[mid] == target) {
                  return mid;
              }
              if (nums[mid] > target) {
                  right = mid; //target 在左区间，所以[left, middle )   -----------不同点-----------
              } else {
                  left = mid + 1;  //target 在右区间，所以[middle + 1, right)
              }
          }
          return -1;
      }
  ```

  

### 【Leetcode典型题目】

- #### [704. 二分查找](https://leetcode.cn/problems/binary-search/)
- #### [35. 搜索插入位置](https://leetcode.cn/problems/search-insert-position/)

- #### [153. 寻找旋转排序数组中的最小值](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/)
- #### [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)
- #### [278. 第一个错误的版本](https://leetcode.cn/problems/first-bad-version/)
- #### [374. 猜数字大小](https://leetcode.cn/problems/guess-number-higher-or-lower/)
- #### [744.寻找比目标字母大的最小字母](https://leetcode.cn/problems/find-smallest-letter-greater-than-target/)
- #### [852. 山脉数组的峰顶索引](https://leetcode.cn/problems/peak-index-in-a-mountain-array/)
- #### [1011. 在 D 天内送达包裹的能力](https://leetcode.cn/problems/capacity-to-ship-packages-within-d-days/)
- 



## 移除元素（双指针法）

通过一个**快指针**和一个**慢指针**，在一个for循环下完成两个for循环的工作。

- 快指针：
- 慢指针：



