# 分布式-锁

## 一、分布式锁

### 锁

单体应用本地锁：Synchronizd、ReentrantLock；

分布式应用分布式锁：分布式应用中，可以把每个应用看成是一个线程，分布式锁，就是为了解决分布式应用处理资源时的并发安全问题。

**锁作用**：保证并发安全、避免重复处理、幂等。

### 分布式锁的功能

- 互斥性：基本功能，一个应用获取锁，另一个应用则获取不到锁；

- 可重入性：一个应用获取锁之后还能再次获取该锁（幂等性：多次持有锁的处理结果一致）；

- 锁超时：应用持有的锁超时后，一定时间后自动释放锁；

- 支持阻塞/非阻塞：获取锁是否需要等待

- 支持公平/非公平锁：获取锁的是否有先后顺序；

- 高效：加/释放锁速度要快；

- 高可用：分布式锁的可用性；

  

## 二、分布式锁实践

- 数据库分布式锁
- Zookeeper分布式锁
- Chubby分布式锁
- Etcd分布式锁
- Redis分布式锁

### 数据库分布式锁

#### 数据库资源锁表

1. ##### 维护资源分布式锁表

   ```mysql
   create table resource_lock(
      'lock_id' int unsigned NOT NULL AUTO_INCREMENT,
      'lock_key' varchar(128) NOT NULL default '' COMMENT '锁资源',
      'node_info' varchar(128) NOT NULL default '' COMMENT '节点/线程信息',
      'reentrant_count' varchar(128) NOT NULL default '0' COMMENT '重入次数',
      'create_time' timestamp NULL default NULL COMMENT '创建时间',
      'update_time' timestamp NULL default NULL COMMENT '更新时间',
     primary key('lock_id'),
     Unique key 'unique_lock_key' ('lock_key') 
   )ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='分布式锁表'
   ```

2. ##### 在资源表增加分布式锁字段

#### 阻塞式获取锁

循环调用lock()函数，直到返回true。

```java
@Transaction //添加事务保证原子性
public boolean lock(){
   //获取资源锁
   ResourcceLock lock = "select * from resorce_lock where lock_key = 'xxx' for update ";
   //如果资源锁不存在
   if(locks.isEmpty()){
       //插入锁
       "insert into resorce_lock ";
        return true;
   }
    //根据节点/线程信息，判断锁是否可重入
   if(cur.nodeInfo == lock.nodeInfo){
     "update resorce_lock set reentrant_count = reentrant_count + 1 where lock_key = 'xxx'";
   }else{
     return false;
   }
   return true;
}
```

#### 非阻塞式获取锁

循环调用lock()函数（阻塞锁），直到返回true或者超时。

```java
public boolean tryLock(long timeout){
   long endTime = System.currentTimeMills + timeout;
   while(true){
     //调用上面的lock()方法
     if(lock()){
       return true;
     }
     //超时判断
     if(endTime < System.currentTimeMills){
       return false;
     }
   }
}
```

#### 释放锁

调用unlock()方法

```java
@Transaction //添加事务保证原子性
public boolean lock(){
   //获取资源锁
   ResourcceLock lock = "select * from resorce_lock where lock_key = 'xxx' for update ";
   //如果资源锁不存在
   if(locks.isEmpty()){
        return true;
   }
    //根据节点/线程信息，判断锁是否可重入
   if(cur.nodeInfo == lock.nodeInfo){
      //释放重入锁
     if(lock.reentrantCount>1){
       "update resorce_lock set reentrant_count = reentrant_count - 1 where lock_key = 'xxx'";
     }else{
       "delete from resorce_lock where lock_key = "xxx"";
     }
   }else{
     //不是自己的锁无法释放
     return false;
   }
   return true;
}
```

#### 锁超时

1. 启动定时任务循环遍历锁，长时间未被释放即为超时，直接删除；
2. 在每次加锁时判断锁是否超时。



#### 数据库分布式锁的特点

##### 使用场景

没有其他中间件可以使用，需要加锁的资源有对应的数据表。

##### 优点

不需要维护其他中间件。

##### 缺点

需要自己实现加/解锁逻辑，性能较差。





## Zookeeper分布式锁

