# 内存结构篇



## 1、什么是Java虚拟机？

```
Java虚拟机是一个可以执行Java字节码的虚拟机进程；
```

## 2、堆与栈区别？

##### 数据结构

```
堆：完全二叉树；
栈：后进先出的线性数据结构；
```

##### 内存区域

##### 堆

```
* 属于线程共享区域；
* 存放是对象实例，及对象的一些属性值：如常量；
* 堆空间较大；
* 会发生OOM异常；
```

##### 栈

```
* 属于线程私有区域；
* 是java方法执行时的区域，方法进入进栈，方法退出出栈；
* 栈空间较小；
* 会发生OOM和SOF异常；
```

## 3、Java内存结构？

##### 线程共享区

```
堆：
方法区：
运行时常量池：
```

##### 线程私有区

```
程序计数器：
虚拟机栈：
本地方法栈：
```

# 对象篇



## 1、对象创建流程？

```
1、类加载检查；
2、分配内存：堆规整，指针碰撞；堆不规整，空闲列表；
3、初始化零值；
4、设置对象头：包含，运行时数据，类型指针，数组长度；
5、执行<init>()指令；
```

## 2、对象结构/组成/内存布局？

````
1、对象头：运行时数据，类型指针，数组长度；
2、实例数据；
3、对齐填充：满足8k对齐；
````

## 3、对象访问方式？

```
1、句柄：堆中维护句柄池，稳定；
2、指针：直接指向对象，速度快；
```

## 4、异常OOM与SOF？

````
SOF：Memory Leak，内存泄漏，资源未及时释放；
OOM：Out Of Memory，内存溢出，内存不足；
````

## 5、对象分配规则？

````
1、优先在Eden区分配：空间不够发起MinorGC/YongGC；
2、大对象直接进入老年代：避免新生代发生大量内存复制；
3、长期存活对象进入老年代：一次MinorGC，年龄+1，超过阈值（15），进入老年代；
4、动态对象年龄判定：Eden区同岁对象大小大于剩余空间大小，同岁及长者对象可进入老年代；
5、空间分配规则：老年代剩余连续空间不足，可设置空间分配规则避免重复发生FullGC；
````

## 6、GC类型？

```
1、MinorGC/YongGC：新生代GC；
2、MajorGC/OldGC：老年代GC，仅CMS垃圾回收器；
3、MixedGC：混合GC，仅G1垃圾回收器；
4、FullGC：Java堆与栈GC；
```

## 7、什么时候发生Full GC？

```
1.调用System.gc；
2.老年代内存不足；
3.老年代内存不足且分配担保失败；
```

# 垃圾回收篇

## 1、为什么要进行垃圾回收？

```
垃圾回收区域：java堆，方法区；
回收原因：垃圾的回收是为了更好的分配内存；
```

## 2、对象判活算法？

##### 引用计数器

```
* 在对象中添加一个引用计数器；
* 每当引用它时，计数器就+1；当引用失效，计数器-1；
* 计数器为0的对象，就是不可再用的。
```

##### 可达性分析

```
* 通过“GC Roots“的根对象作为起始节点集向下搜索（路径称为：引用链）；
* 如果某个对象到GC Roots间没有任何引用链相连，证明对象不可能再使用。
```

## 3、GC Roots？

##### GC Roots都是对象

```
虚拟机栈(本地变量表)中引用的对象；
方法区中的静态属性、常量引用的对象；
被同步锁(Synchronized)持有的对象；
本地方法栈中JNI(Native方法)引用的对象；
Java虚拟机内部引用: 基本数据类型对应的Class对象、类加载器等。
```

## 4、可达性分析中的两次标记，最后的补救？

````
* 第一次标记: 是否与GC Roots相连，
     - 是，存活，
     - 否，有无必要执行finalize()方法；
          - 无，宣告死亡，
          - 有，放入F-Queue队列(由Finalizer线程去执行Finalize()方法)；
* 第二次标记： 对F-Queue中的对象，有无重新引用，
     - 有，存活，
     - 无，死亡。
````

## 5、对象的引用？

````
强引用：只要强引用存在,就不会被回收的对象; Object
软引用：在将要发生内存溢出异常前的第二次回收后还没有足够内存,才抛出内存溢出异常; SoftReference
弱引用：生存到下次垃圾回收的对象; WeakReference
虚引用：唯一目的为了能在回收这个对象时收到系统通知; PhantomReference
````

## 6、垃圾回收算法？

##### 新生代：标记-复制；

##### 老年代：标记-清除（产生碎片）、标记-整理。

##### 分代收集算法

## 7、垃圾回收器？

##### 新生代（标记-复制）

```
* Serial：单线程，标记-复制，搭配Serial Old使用；
* PerNew：支持并发，Serial的多线程版本，标记-复制，搭配CMS使用；
* Parallel Scavenge：支持并行，注重吞吐量，标记-复制，搭配Parallel Old使用；
```

##### 老年代（标记-清除（产生碎片）、标记-整理）

````
* Serial Old：单线程，Serial的老年代版本，标记-整理，CMS的后备预案；
* Parallel Old：Parallel Scavenge的老年代版本，标记-整理，搭配搭配Parallel Scavenge使用
* CMS：
   -获取最短停顿时间为目标；
   -标记-清除
   -过程：初始标记、并发标记、重新标记、并发清除；
   -缺点：对CPU资源敏感；无法处理浮动垃圾；内存产生大量碎片；
````

##### 新型

````
G1：
  -Regin划分堆内存，按优先级回收；
  -步骤：初始标记、并发标记、最终标记、筛选回收；
````

# 调优篇



## 1、调优命令？

```
* jps：显示指定系统内所有的HotSpot虚拟机进程；
* jstat：监视虚拟机运行时状态信息，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据；
* jmap：生成heap dump文件；
* jhat：与jmap搭配使用，用来分析jmap生成的dump，可以在浏览器中查看分析结果；
* jstack：用于生成java虚拟机当前时刻的线程快照；
* jinfo：查看和调整虚拟机运行参数；
```

## 2、调优工具？

##### JDK自带

```
* jconsole：从java5开始，在JDK中自带的java监控和管理控制台，用于对JVM中内存，线程和类等的监控;
* jvisualvm：jdk自带全能工具，可以分析内存快照、线程快照；监控内存变化、GC变化等。
```

##### 第三方

```
* MAT：基于Eclipse的内存分析工具，是一个快速、功能丰富的Java heap分析工具，它可以帮助我们查找内存泄漏和减少内存消耗;
* GChisto：一款专业分析gc日志的工具;
```

## 3、JVM核心参数？

```
虚拟机栈：-Xss
java堆：-Xms -Xmx
永久代：-XX:PermSize -XX:MaxPermSize
JDK1.8后，使用Meta Space替代了Perm Space，MetaSpace大小默认没有限制，一般根据系统内存的大小。JVM会动态改变此值。
-XX:MetaspaceSize：分配给类元数据空间的初始值；
-XX:MaxMetaspaceSize：分配给类元数据空间的最大值，超过此值会触发FullGC，此值默认没有限制，取决于系统内存的大小。JVM会动态地改变此值。
```

# 类加载机制篇

## 1、什么是类加载？

````
虚拟机把描述类的Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可被虚拟机直接使用的Java类型；
````

## 2、类的生命周期？

```
加载、验证、准备、解析、初始化、使用、卸载；
```

## 3、类加载阶段？

```
* 加载：将字节流转化为一个代表类的Class文件；
* 验证：为了确保字节流中包含的信息的安全性；
* 准备：为类变量分配内存，并设置初始值；
* 解析：虚拟机将常量池中的符号引用替换为直接引用；
* 初始化：执行类构造器<clinit>()方法；
```

## 4、类加载器？

```
* 启动类加载器：BootStrap ClassLoader，虚拟机的一部分，加载“\bin”目录下的类；
* 扩展类加载器：Extension ClassLoader，加载\bin\ext目录下的类；
* 程序类加载器：Application ClassLoader，加载用户类路径上文件；
除启动类加载器外，类加载器都应有自己的父类加载器，加载器的父子关系不是继承，而是使用“组合”方式来复用父加载器的代码；
```

## 5、什么是双亲委派机制？

```
类加载之间的层次关系；
```

## 6、双亲委派模型工作过程？

```
类加载器接收到加载请求，将请求委派给父类加载器加载，直至顶层；
当父类加载器反馈不能加载时，子类加载器才能去加载。
```

## 7、破坏双亲委派？

```
热代码替换、模块化热部署（OSGi）
```

# Java内存模型篇（JMM）

## 1、什么是Java内存模型？

```
用来屏蔽各种硬件和操作系统的内存访问差异，让java程序在各种平台下达到一致的访问效果；
是围绕并发过程中如何处理原子性、有序性和可见性来建立的；
```

## 2、主内存与工作内存？

```
* 工作内存：线程私有，每个线程工作的区域；
* 主内存：线程共享，存储成员变量的区域；
```

##### 模型特点：

```
1，所有的成员变量都存储在主内存；
2，每条线程都有自己的工作内存；
3，线程的工作内存保存并使用主线程变量的副本拷贝；
4，线程对变量的所有操作（赋值）都在工作内存；
5，不同线程不能直接访问对方工作内存中的变量；
6，线程间的通信依靠主内存来完成；
```

## 3、内存间的交互操作（8种）？

```
* 主线程：lock，unlock，read，write；
* 工作内存：load，use，assign，store。
```

## 4、先行发生原则（8条）？

##### 判断数据是否存在竞争，线程是否安全的重要依据；

```
1. 程序次序原则：按照代码书写顺序，书写在前面的操作先行发生于书写后面的操作；
2. 管程锁定原则：一个unlock操作先行发生于后面对同一锁的lock操作；
3. volatile变量规则：对volatile变量的写操作先行发生于后面对该变量的读操作；
4. 线程启动原则：Thread对象的start()方法先行发生于此线程的每一个操作；
5. 线程终止原则：线程中的所有操作都先行发生于对此线程的终止检测；
6. 线程中断对则：对线程interrupt()方法的调用先行发生于被中断线程代码检测到中断的发生；
7. 传递性：如果A先行发生于B，B先行发生于C，则A先行发生于C；
```

## 5、volatile变量？

##### volatile，是java最轻量级的同步机制；

##### 特性

```
可见性：通过强制刷新变量值到主内存实现；
有序性：通过内存屏障指令实现；
```

### ！！！注意：volatile需要加锁来实现原子性

## 6、可见性、有序性、原子性？

```
* 可见性：强制刷新工作内存值到主内存实现的；
* 有序性：volatile通过内存屏障实现，Synchronized通过“一个变量一个时刻只允许一条线程对其进行lock操作”实现；
* 原子性：Sychronized关键字，显式或隐式地使用monitorenter和monitorexit指令来实现的；
```







