# 内存布局篇



## 1、什么是Java虚拟机？

```
Java虚拟机是一个可以执行Java字节码的虚拟机进程；
```

## 2、堆与栈区别？

##### 数据结构

```
堆：；
栈：；
```

##### 内存区域

堆

```
* 属于线程共享区域；
* 存放是对象实例，及对象的一些属性值：如常量；
* 堆空间较大；
* 会发生OOM异常；
```

栈

```
* 属于线程私有区域；
* 是java方法执行时的区域，方法进入进栈，方法退出出栈；
* 栈空间较小；
* 会发生OOM和SOF异常；
```

## 3、Java内存结构？

##### 线程共享区

```
堆：
方法区：
运行时常量池：
```

##### 线程私有区

```
程序计数器：
虚拟机栈：
本地方法栈：
```

# 对象篇



## 1、对象创建流程？

```
1、类加载检查；
2、分配内存：堆规整，指针碰撞；堆不规整，空闲列表；
3、初始化零值；
4、设置对象头：包含，运行时数据，类型指针，数组长度；
5、执行<init>()指令；
```

## 2、对象结构/组成/内存布局？

````
1、对象头：运行时数据，类型指针，数组长度；
2、实例数据；
3、对齐填充：满足8k对齐；
````

## 3、对象访问方式？

```
1、句柄：堆中维护句柄池，稳定；
2、指针：直接指向对象，速度快；
```

## 4、异常OOM与SOF？

````
SOF：Memory Leak，内存泄漏，资源未及时释放；
OOM：Out Of Memory，内存溢出，内存不足；
````

## 5、对象分配规则？

````
1、优先在Eden区分配：空间不够发起MinorGC/YongGC；
2、大对象直接进入老年代：避免新生代发生大量内存复制；
3、长期存活对象进入老年代：一次MinorGC，年龄+1，超过阈值（15），进入老年代；
4、动态对象年龄判定：Eden区同岁对象大小大于剩余空间大小，同岁及长者对象可进入老年代；
5、空间分配规则：老年代剩余连续空间不足，可设置空间分配规则避免重复发生FullGC；
````

## 6、GC类型？

```
1、MinorGC/YongGC：新生代GC；
2、MajorGC/OldGC：老年代GC，仅CMS垃圾回收器；
3、MixedGC：混合GC，仅G1垃圾回收器；
4、FullGC：Java堆与栈GC；
```

## 7、什么时候发生Full GC？

```
1.调用System.gc；
2.老年代内存不足；
3.老年代内存不足且分配担保失败；
```

# 垃圾回收篇

## 1、为什么要进行垃圾回收？

```
垃圾回收区域：java堆，方法区；
回收原因：垃圾的回收是为了更好的分配内存；
```

## 2、对象判活算法？

##### 引用计数器

```
* 在对象中添加一个引用计数器；
* 每当引用它时，计数器就+1；当引用失效，计数器-1；
* 计数器为0的对象，就是不可再用的。
```

##### 可达性分析

```
* 通过“GC Roots“的根对象作为起始节点集向下搜索（路径称为：引用链）；
* 如果某个对象到GC Roots间没有任何引用链相连，证明对象不可能再使用。
```

## 3、GC Roots？

##### GC Roots都是对象

```
虚拟机栈(本地变量表)中引用的对象；
方法区中的静态属性、常量引用的对象；
被同步锁(Synchronized)持有的对象；
本地方法栈中JNI(Native方法)引用的对象；
Java虚拟机内部引用: 基本数据类型对应的Class对象、类加载器等。
```

## 4、可达性分析中的两次标记，最后的补救？

````
* 第一次标记: 是否与GC Roots相连，
     - 是，存活，
     - 否，有无必要执行finalize()方法；
          - 无，宣告死亡，
          - 有，放入F-Queue队列(由Finalizer线程去执行Finalize()方法)；
* 第二次标记： 对F-Queue中的对象，有无重新引用，
     - 有，存活，
     - 无，死亡。
````

## 5、对象的引用？

````
强引用：只要强引用存在,就不会被回收的对象; Object
软引用：在将要发生内存溢出异常前的第二次回收后还没有足够内存,才抛出内存溢出异常; SoftReference
弱引用：生存到下次垃圾回收的对象; WeakReference
虚引用：唯一目的为了能在回收这个对象时收到系统通知; PhantomReference
````

## 6、垃圾回收算法？

##### 新生代：标记-复制；

##### 老年代：标记-清除（产生碎片）、标记-整理。

##### 分代收集算法

## 7、垃圾回收器？

##### 新生代（标记-复制）

```
Serial：单线程，标记-复制算法，搭配Serial Old使用；
PerNew：Serial的多线程版本
Parallel Scavenge：
```

##### 老年代（标记-清除（产生碎片）、标记-整理）

````
Serial Old：
Parallel Old
CMS：
````

##### 新型

````
G1：
````

# 调优篇



## 1、调优命令？

```
* jps：显示指定系统内所有的HotSpot虚拟机进程；
* jstat：监视虚拟机运行时状态信息，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据；
* jmap：生成heap dump文件；
* jhat：与jmap搭配使用，用来分析jmap生成的dump，可以在浏览器中查看分析结果；
* jstack：用于生成java虚拟机当前时刻的线程快照；
* jinfo：查看和调整虚拟机运行参数；
```

## 2、调优工具？

##### JDK自带

```
jconsole：从java5开始，在JDK中自带的java监控和管理控制台，用于对JVM中内存，线程和类等的监控;
jvisualvm：jdk自带全能工具，可以分析内存快照、线程快照；监控内存变化、GC变化等。
```

##### 第三方

```
MAT：基于Eclipse的内存分析工具，是一个快速、功能丰富的Java heap分析工具，它可以帮助我们查找内存泄漏和减少内存消耗;
GChisto：一款专业分析gc日志的工具;
```

## 3、性能调优？

```
```

# 类加载机制篇

## 1、什么是类加载？

````
虚拟机把描述类的Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可被虚拟机直接使用的Java类型；
````

## 2、类的生命周期？

```
加载、验证、准备、解析、初始化、使用、卸载；
```

## 3、类加载阶段？

```
```

4、类加载器

```
启动类加载器：
```





5、什么是双亲委派机制？

6、破坏双亲委派？